import matplotlib
# Use 'Qt5Agg' or 'TkAgg' for proper interactive plotting in some environments
# The user's original preference is kept, but it might need adjustment based on system.
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
plt.ion()  # Interactive mode on, though plt.show(block=True) is used at the end

import numpy as np
from math import cos, sin, atan2, acos, sqrt, degrees, radians, isclose

# --- Constants and Setup ---
# Tolerance for floating point comparisons
TOLERANCE = 1e-6

class DHLink:
    """Represents a single link with Denavit-Hartenberg parameters."""
    def __init__(self, a, alpha, d, theta_offset=0):
        self.a = a          # Link length (m)
        self.alpha = alpha  # Link twist (rad)
        self.d = d          # Link offset (m)
        self.theta_offset = theta_offset # Joint angle offset (rad)

def dh_transform(a, alpha, d, theta):
    """Calculates the homogeneous transformation matrix (4x4) for a single DH link."""
    ct, st = cos(theta), sin(theta)
    ca, sa = cos(alpha), sin(alpha)
    return np.array([
        [ct, -st * ca,  st * sa, a * ct],
        [st,  ct * ca, -ct * sa, a * st],
        [0,        sa,        ca,      d],
        [0,         0,         0,      1]
    ])

def forward_kinematics_DH(links, thetas):
    """Calculates the end-effector pose T_0_n from the base frame (0) to the final frame (n)."""
    T = np.eye(4)
    for i, link in enumerate(links):
        # Calculate the transformation for the current joint angle plus its offset
        T_i = dh_transform(link.a, link.alpha, link.d, thetas[i] + link.theta_offset)
        T = T @ T_i  # Chain transformations
    return T

def inverse_kinematics_3R_planar(x, y, phi, links):
    """
    Calculates the joint angles (theta1, theta2, theta3) for a 3R planar arm
    using the algebraic solution (geometric method).
    
    The planar arm has links with L1, L2, L3 and all alpha=0, d=0.
    It solves for the wrist position (Wx, Wy) first, then the shoulder angle (theta1)
    and elbow angle (theta2). Finally, theta3 is found using the desired orientation (phi).
    """
    l1, l2, l3 = links[0].a, links[1].a, links[2].a

    # 1. Calculate wrist position (Wx, Wy)
    # W is the center of joint 3.
    wx = x - l3 * cos(phi)
    wy = y - l3 * sin(phi)

    # 2. Solve for theta2 (Elbow) using the Law of Cosines (for the 2R sub-problem)
    # Cosine of theta2, based on the triangle formed by l1, l2, and the wrist vector magnitude |W|
    D = (wx**2 + wy**2 - l1**2 - l2**2) / (2 * l1 * l2)

    # Check for reachability (D must be between -1 and 1)
    if abs(D) > 1 + TOLERANCE:
        return None

    D = np.clip(D, -1.0, 1.0) # Clip to avoid domain errors near tolerance limits

    # Two possible solutions for theta2 (Elbow Up/Down)
    # theta2_1 (Elbow Down/Extended) and theta2_2 (Elbow Up/Folded)
    theta2_1 = acos(D)
    theta2_2 = -acos(D) # Elbow Up is usually positive, Elbow Down is negative in standard math,
                        # but depends on chosen frame. We use +/- acos(D) for the two distinct solutions.

    solutions = []

    for theta2 in [theta2_1, theta2_2]:
        # 3. Solve for theta1 (Shoulder)
        k1 = l1 + l2 * cos(theta2)
        k2 = l2 * sin(theta2)
        
        # theta1 = atan2(Wy, Wx) - atan2(k2, k1)
        # atan2(Wy, Wx) is the angle of the wrist vector W in the base frame.
        # atan2(k2, k1) is the angle correction based on the chosen elbow configuration (theta2).
        theta1 = atan2(wy, wx) - atan2(k2, k1)

        # Normalize theta1 to [-pi, pi] for cleaner results
        theta1 = atan2(sin(theta1), cos(theta1))

        # 4. Solve for theta3 (Wrist)
        # phi = theta1 + theta2 + theta3 (since alpha=0 for all links)
        theta3 = phi - theta1 - theta2
        
        # Normalize theta3 to [-pi, pi]
        theta3 = atan2(sin(theta3), cos(theta3))

        solutions.append((theta1, theta2, theta3))
        
    return solutions

def is_singular(theta2):
    """Checks if the arm is in a singularity (theta2 = 0 or pi)."""
    return isclose(sin(theta2), 0, abs_tol=TOLERANCE)

def plot_workspace(links, resolution=30):
    """
    Plots the full reachable workspace of the 3R planar arm.
    The workspace is defined by the maximum reach (R_max) and minimum reach (R_min).
    A dense scatter plot is generated by varying all joint angles (theta1, theta2, theta3).
    """
    l1, l2, l3 = links[0].a, links[1].a, links[2].a
    
    # 1. Generate grid of joint angles
    # Vary all three joints to map the complete 3R workspace
    theta = np.linspace(-np.pi, np.pi, resolution)
    T1_grid, T2_grid, T3_grid = np.meshgrid(theta, theta, theta)

    # Flatten the grid arrays for easier calculation
    T1_flat = T1_grid.flatten()
    T2_flat = T2_grid.flatten()
    T3_flat = T3_grid.flatten()

    # 2. Calculate x and y using full forward kinematics for every configuration
    # X = L1*c(T1) + L2*c(T1+T2) + L3*c(T1+T2+T3)
    # Y = L1*s(T1) + L2*s(T1+T2) + L3*s(T1+T2+T3)
    X = (l1 * np.cos(T1_flat) +
         l2 * np.cos(T1_flat + T2_flat) +
         l3 * np.cos(T1_flat + T2_flat + T3_flat))
    Y = (l1 * np.sin(T1_flat) +
         l2 * np.sin(T1_flat + T2_flat) +
         l3 * np.sin(T1_flat + T2_flat + T3_flat))

    # 3. Plot the workspace points
    plt.figure("Workspace of 3-DOF Planar Arm", figsize=(8, 8))
    plt.scatter(X, Y, s=1, c='skyblue', alpha=0.05) # Use low alpha for density map

    # 4. Plot the theoretical boundaries
    max_r = l1 + l2 + l3
    # Minimum reach is 0 if l1 is not much larger than l2+l3 (i.e., if base can reach origin)
    min_r = abs(l1 - l2 - l3) if l1 > l2 + l3 else 0
    boundary_t = np.linspace(0, 2*np.pi, 100)
    
    plt.plot(max_r * np.cos(boundary_t), max_r * np.sin(boundary_t), 'r--', lw=1.5, label='Max Reach')
    if min_r > 0:
        plt.plot(min_r * np.cos(boundary_t), min_r * np.sin(boundary_t), 'r--', lw=1.5, label='Min Reach')

    plt.title(f"Workspace of 3R Planar Arm ($L_1={l1}, L_2={l2}, L_3={l3}$)")
    plt.xlabel("X Position (m)")
    plt.ylabel("Y Position (m)")
    plt.axis('equal')
    plt.grid(True, linestyle=':', alpha=0.6)
    plt.legend(loc='upper right')
    plt.gca().set_aspect('equal', adjustable='box')


def plot_arm(thetas, links, target=None, solution_number=1, pos_error=None):
    """Plots the robotic arm configuration based on joint angles."""
    
    # 1. Calculate joint positions
    x_points = [0]
    y_points = [0]
    T = np.eye(4)
    
    for i, theta in enumerate(thetas):
        T = T @ dh_transform(links[i].a, links[i].alpha, links[i].d, theta + links[i].theta_offset)
        x_points.append(T[0, 3])
        y_points.append(T[1, 3])
        
    # 2. Get plotting limits based on total arm length and target
    max_dim = sum([l.a for l in links]) * 1.1
    if target is not None:
        max_dim = max(max_dim, abs(target[0]) * 1.5, abs(target[1]) * 1.5)
        
    # 3. Create figure
    plt.figure(f"Arm Configuration (Solution {solution_number})", figsize=(8, 8))
    
    # Draw arm links
    plt.plot(x_points, y_points, 'o-', color='darkgreen', lw=5, markersize=10, 
             markerfacecolor='white', markeredgecolor='darkgreen', label='Arm Links')
    
    # Draw base joint (J0)
    plt.plot(0, 0, 'ks', markersize=12, label='Base Joint')
    
    # Draw intermediate joints (J1, J2)
    plt.plot(x_points[1:-1], y_points[1:-1], 'ko', markersize=8, label='Joints 1 & 2')

    # Draw End Effector (J3)
    ee_label = 'End Effector'
    if pos_error is not None:
         ee_label += f' (Error: {pos_error:.3e} m)'
         
    plt.plot(x_points[-1], y_points[-1], 'ro', markersize=12, label=ee_label)
    
    # Draw target
    if target is not None:
        plt.plot(target[0], target[1], 'kx', markersize=15, mew=3, label='Target Pose')
        # Draw a line from the end-effector to the target to visualize error
        plt.plot([x_points[-1], target[0]], [y_points[-1], target[1]], 'k:', alpha=0.5, lw=1)

    # 4. Final plot aesthetics
    title = f"3-DOF Arm Solution {solution_number} | $T_1$={degrees(thetas[0]):.1f}° $T_2$={degrees(thetas[1]):.1f}° $T_3$={degrees(thetas[2]):.1f}°"
    
    plt.title(title)
    plt.xlabel("X Position (m)")
    plt.ylabel("Y Position (m)")
    
    # Set limits based on calculated max_dim
    plt.xlim(-max_dim, max_dim)
    plt.ylim(-max_dim, max_dim)
    
    plt.axis('equal')
    plt.grid(True, alpha=0.4)
    plt.legend()
    plt.gca().set_aspect('equal', adjustable='box')
    plt.show(block=False)


def main():
    """Main function to run the simulator and user interaction."""
    print("\n=======================================================")
    print("=== 3-DOF Planar Arm Inverse Kinematics Simulator ===")
    print("=======================================================\n")
    
    # --- 1. Input Link Lengths and Define Arm ---
    try:
        l1 = float(input("Enter length of link L1 (e.g., 1.0): "))
        l2 = float(input("Enter length of link L2 (e.g., 1.0): "))
        l3 = float(input("Enter length of link L3 (e.g., 0.5): "))
    except ValueError:
        print("Invalid input. Please enter a valid number.")
        return

    # Define the 3R planar arm links (alpha=0, d=0 for planar RRR)
    links = [
        DHLink(a=l1, alpha=0, d=0),
        DHLink(a=l2, alpha=0, d=0),
        DHLink(a=l3, alpha=0, d=0)
    ]
    max_reach = l1 + l2 + l3

    # --- 2. Plot Workspace ---
    print("\n--- Generating Workspace Plot (Window: 'Workspace of 3-DOF Planar Arm') ---")
    plot_workspace(links)

    # --- 3. Input Target Pose ---
    print("\n--- Set Target Pose ---")
    try:
        x = float(input(f"Set cartesian X coordinate (max reach: {max_reach:.2f}): "))
        y = float(input(f"Set cartesian Y coordinate (max reach: {max_reach:.2f}): "))
        phi_deg = float(input("Set desired end-effector orientation (phi, degrees): "))
        phi = radians(phi_deg)
    except ValueError:
        print("Invalid input. Please enter a valid number.")
        # Ensure plots still show on exit
        plt.show(block=True)
        return

    # --- 4. Calculate Inverse Kinematics ---
    sols = inverse_kinematics_3R_planar(x, y, phi, links)

    if sols is None:
        dist = sqrt(x**2 + y**2)
        print(f"\n[ERROR] Target unreachable.")
        print(f"Target distance: {dist:.2f}, Max arm reach: {max_reach:.2f}")
    else:
        print("\n--- Found Solutions ---")
        
        # --- 5. Output and Plot Solutions ---
        for i, (t1, t2, t3) in enumerate(sols):
            # Verify the solution with Forward Kinematics
            T = forward_kinematics_DH(links, [t1, t2, t3])
            x_fk, y_fk = T[0, 3], T[1, 3]
            pos_err = sqrt((x_fk - x)**2 + (y_fk - y)**2)

            print(f"\nSolution {i+1} (Elbow {'Up' if t2 > 0 else 'Down'}):")
            print(f"  > Joint Angles (degrees): T1={degrees(t1):.2f}°, T2={degrees(t2):.2f}°, T3={degrees(t3):.2f}°")
            print(f"  > FK Position Error: {pos_err:.6e} m")
            
            if is_singular(t2):
                print("  [Warning: Singularity detected (Elbow straight/folded)]")
            
            # Plot the current arm configuration for the solution
            plot_arm([t1, t2, t3], links, target=(x, y), solution_number=i+1, pos_error=pos_err)
            
    print("\n--- Displaying Plots ---")
    # Block execution until all plots are manually closed
    plt.show(block=True)

if __name__ == "__main__":
    main()
